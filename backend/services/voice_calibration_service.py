"""
Voice Calibration Service - Phase 2B of Writer's Factory

Runs voice calibration tournaments where multiple AI agents compete to capture
the writer's desired narrative voice. Generates Voice Reference Bundle files
that travel with every agent call during Director Mode.

Key Concepts:
- Tournament: Multiple agents write the same test passage
- Multiplier: Each agent produces 5 creative variants (verbalized sampling)
- Voice Reference Bundle: Files that define the voice for scene writing
"""

import asyncio
import json
import logging
import os
import re
import yaml
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from backend.services.llm_service import LLMService
from backend.services.foreman_kb_service import get_foreman_kb_service

logger = logging.getLogger(__name__)


# =============================================================================
# Data Classes
# =============================================================================

class TournamentStatus(Enum):
    """Status of a voice calibration tournament."""
    NOT_STARTED = "not_started"
    RUNNING = "running"
    AWAITING_SELECTION = "awaiting_selection"
    COMPLETE = "complete"
    FAILED = "failed"


@dataclass
class AgentInfo:
    """Information about an available agent."""
    id: str
    name: str
    provider: str
    model: str
    role: str
    enabled: bool
    has_valid_key: bool
    use_cases: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class VoiceVariant:
    """A single voice sample generated by an agent."""
    agent_id: str
    agent_name: str
    variant_number: int  # 1-5
    strategy: str  # e.g., "ACTION_EMPHASIS", "CHARACTER_DEPTH"
    content: str
    word_count: int
    generated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class TournamentResult:
    """Results from a voice calibration tournament."""
    tournament_id: str
    project_id: str
    test_prompt: str
    test_context: str
    status: TournamentStatus
    selected_agents: List[str]  # Agent IDs that participated
    variants: List[VoiceVariant] = field(default_factory=list)
    winner_agent_id: Optional[str] = None
    winner_variant_index: Optional[int] = None
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    completed_at: Optional[str] = None

    def to_dict(self) -> Dict:
        return {
            **asdict(self),
            'status': self.status.value,
            'variants': [v.to_dict() for v in self.variants],
        }


@dataclass
class VoiceCalibrationDocument:
    """The structured output from voice calibration - stored in KB."""
    project_id: str
    pov: str  # "first_person" | "third_limited" | "third_omniscient"
    tense: str  # "past" | "present"
    voice_type: str  # "character_voice" | "author_voice"
    metaphor_domains: List[str]
    sentence_rhythm: str
    vocabulary_level: str
    characteristic_phrases: List[str]
    anti_patterns: List[str]
    phase_evolution: Dict[str, str]  # act -> voice_state
    winning_agent: str
    reference_sample: str  # The winning variant text
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

    def to_dict(self) -> Dict:
        return asdict(self)


# =============================================================================
# Voice Calibration Service
# =============================================================================

class VoiceCalibrationService:
    """
    Manages voice calibration tournaments and generates Voice Reference Bundles.

    Flow:
    1. get_available_agents() - Show writer what's available
    2. start_tournament() - Writer picks agents and provides test text
    3. get_tournament_status() - Poll for completion
    4. select_winner() - Writer picks winning variant
    5. generate_voice_bundle() - Create reference files for Director Mode
    """

    # Multiplier strategies for variant generation
    VARIANT_STRATEGIES = [
        ("ACTION_EMPHASIS", "Fast pacing, physical detail, external conflict, dialogue in motion"),
        ("CHARACTER_DEPTH", "Slower pacing, internal landscape, psychology foregrounded"),
        ("DIALOGUE_FOCUS", "Conversation-centered, conflict through words, subtext"),
        ("ATMOSPHERIC", "Setting as character, sensory immersion, mood emphasized"),
        ("BALANCED", "Mix of elements, standard structure, reliable execution"),
    ]

    def __init__(self, agents_yaml_path: str = None):
        """
        Initialize the voice calibration service.

        Args:
            agents_yaml_path: Path to agents.yaml. Defaults to project root.
        """
        self.llm_service = LLMService()
        self.kb_service = get_foreman_kb_service()

        # Load agent configurations
        if agents_yaml_path is None:
            # Default to project root
            agents_yaml_path = Path(__file__).parent.parent.parent / "agents.yaml"

        self.agents_config = self._load_agents_config(agents_yaml_path)
        self._tournaments: Dict[str, TournamentResult] = {}

    def _load_agents_config(self, config_path: Path) -> Dict[str, Any]:
        """Load agent configurations from YAML."""
        try:
            with open(config_path, 'r') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            logger.warning(f"agents.yaml not found at {config_path}, using empty config")
            return {"agents": []}

    def _check_api_key_valid(self, agent_config: Dict) -> bool:
        """Check if an agent's API key is configured and not a placeholder."""
        api_key_env = agent_config.get('api_key_env')
        if not api_key_env:
            # Local models (like Ollama) don't need keys
            return agent_config.get('provider') == 'ollama'

        api_key = os.getenv(api_key_env, "")
        # Check for missing or placeholder keys
        if not api_key or api_key == "missing-key" or api_key.startswith("sk-xxx"):
            return False
        return True

    # =========================================================================
    # Public API
    # =========================================================================

    def get_available_agents(self, use_case: str = "tournament") -> List[AgentInfo]:
        """
        Get list of available agents for tournaments.

        Args:
            use_case: Filter by use case (default: "tournament")

        Returns:
            List of AgentInfo objects with availability status
        """
        agents = []

        for agent_config in self.agents_config.get('agents', []):
            use_cases = agent_config.get('use_cases', [])

            # Filter by use case if specified
            if use_case and use_case not in use_cases:
                continue

            has_valid_key = self._check_api_key_valid(agent_config)

            agents.append(AgentInfo(
                id=agent_config['id'],
                name=agent_config['name'],
                provider=agent_config['provider'],
                model=agent_config['model'],
                role=agent_config.get('role', ''),
                enabled=agent_config.get('enabled', False),
                has_valid_key=has_valid_key,
                use_cases=use_cases,
            ))

        return agents

    def get_ready_agents(self, use_case: str = "tournament") -> List[AgentInfo]:
        """Get only agents that are enabled AND have valid API keys."""
        return [
            agent for agent in self.get_available_agents(use_case)
            if agent.enabled and agent.has_valid_key
        ]

    async def start_tournament(
        self,
        project_id: str,
        test_prompt: str,
        test_context: str,
        agent_ids: List[str],
        variants_per_agent: int = 5,
        voice_description: Optional[str] = None,
    ) -> TournamentResult:
        """
        Start a voice calibration tournament.

        Args:
            project_id: The project identifier
            test_prompt: The test passage to write (200-500 words prompt)
            test_context: Context about the scene (setting, characters, mood)
            agent_ids: List of agent IDs to include in tournament
            variants_per_agent: Number of variants per agent (default 5)
            voice_description: Optional writer's description of desired voice

        Returns:
            TournamentResult with tournament_id for tracking
        """
        tournament_id = f"tournament_{project_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        result = TournamentResult(
            tournament_id=tournament_id,
            project_id=project_id,
            test_prompt=test_prompt,
            test_context=test_context,
            status=TournamentStatus.RUNNING,
            selected_agents=agent_ids,
        )

        self._tournaments[tournament_id] = result

        # Run tournament in background
        asyncio.create_task(
            self._run_tournament(
                result,
                variants_per_agent,
                voice_description,
            )
        )

        return result

    async def _run_tournament(
        self,
        result: TournamentResult,
        variants_per_agent: int,
        voice_description: Optional[str],
    ):
        """Execute the tournament - generate variants from all agents."""
        try:
            # Build system prompt for voice generation
            system_prompt = self._build_voice_generation_prompt(
                result.test_context,
                voice_description,
            )

            # Generate variants from each agent
            tasks = []
            for agent_id in result.selected_agents:
                agent_config = self._get_agent_config(agent_id)
                if not agent_config:
                    logger.warning(f"Agent {agent_id} not found, skipping")
                    continue

                for i, (strategy_name, strategy_desc) in enumerate(self.VARIANT_STRATEGIES[:variants_per_agent]):
                    tasks.append(
                        self._generate_variant(
                            agent_config,
                            system_prompt,
                            result.test_prompt,
                            strategy_name,
                            strategy_desc,
                            i + 1,
                        )
                    )

            # Run all generations concurrently
            variants = await asyncio.gather(*tasks, return_exceptions=True)

            # Collect successful variants
            for variant in variants:
                if isinstance(variant, VoiceVariant):
                    result.variants.append(variant)
                elif isinstance(variant, Exception):
                    logger.error(f"Variant generation failed: {variant}")

            result.status = TournamentStatus.AWAITING_SELECTION

        except Exception as e:
            logger.error(f"Tournament failed: {e}")
            result.status = TournamentStatus.FAILED

    def _get_agent_config(self, agent_id: str) -> Optional[Dict]:
        """Get agent configuration by ID."""
        for agent in self.agents_config.get('agents', []):
            if agent['id'] == agent_id:
                return agent
        return None

    def _build_voice_generation_prompt(
        self,
        test_context: str,
        voice_description: Optional[str],
    ) -> str:
        """Build the system prompt for voice sample generation."""
        prompt = """You are participating in a voice calibration tournament for a novel.
Your task is to write a passage that demonstrates a distinctive narrative voice.

CONTEXT:
{context}

{voice_section}

REQUIREMENTS:
- Write in the specified voice consistently
- Show, don't tell - embed personality in observations
- Use sensory details and physical grounding
- Avoid AI-typical patterns like "crucial", "tapestry", "nestled", "in the heart of"
- No meta-commentary or academic analysis
- Aim for 300-500 words

Write the passage now. Do not include any preamble or explanation - just the creative writing."""

        voice_section = ""
        if voice_description:
            voice_section = f"""VOICE DESCRIPTION (from writer):
{voice_description}

Capture this voice authentically."""

        return prompt.format(
            context=test_context,
            voice_section=voice_section,
        )

    async def _generate_variant(
        self,
        agent_config: Dict,
        system_prompt: str,
        test_prompt: str,
        strategy_name: str,
        strategy_desc: str,
        variant_number: int,
    ) -> VoiceVariant:
        """Generate a single voice variant from an agent."""

        # Add strategy to the prompt
        full_prompt = f"""STRATEGY: {strategy_name}
{strategy_desc}

SCENE TO WRITE:
{test_prompt}"""

        try:
            response = await self.llm_service.generate_response(
                provider=agent_config['provider'],
                model=agent_config['model'],
                system_role=system_prompt,
                prompt=full_prompt,
            )

            # Check for error responses
            if response.startswith("Error"):
                raise Exception(response)

            word_count = len(response.split())

            return VoiceVariant(
                agent_id=agent_config['id'],
                agent_name=agent_config['name'],
                variant_number=variant_number,
                strategy=strategy_name,
                content=response,
                word_count=word_count,
            )

        except Exception as e:
            logger.error(f"Failed to generate variant from {agent_config['id']}: {e}")
            raise

    def get_tournament_status(self, tournament_id: str) -> Optional[TournamentResult]:
        """Get the current status of a tournament."""
        return self._tournaments.get(tournament_id)

    def get_tournament_variants(
        self,
        tournament_id: str,
        agent_id: Optional[str] = None,
    ) -> List[VoiceVariant]:
        """
        Get variants from a tournament.

        Args:
            tournament_id: The tournament to query
            agent_id: Optional filter by agent

        Returns:
            List of variants, optionally filtered
        """
        result = self._tournaments.get(tournament_id)
        if not result:
            return []

        variants = result.variants
        if agent_id:
            variants = [v for v in variants if v.agent_id == agent_id]

        return variants

    async def select_winner(
        self,
        tournament_id: str,
        winner_agent_id: str,
        winner_variant_index: int,
        voice_config: Dict[str, Any],
    ) -> VoiceCalibrationDocument:
        """
        Select the winning variant and generate Voice Calibration Document.

        Args:
            tournament_id: The tournament
            winner_agent_id: The winning agent's ID
            winner_variant_index: Index of winning variant (0-based within agent's variants)
            voice_config: Writer's voice configuration choices:
                - pov: "first_person" | "third_limited" | "third_omniscient"
                - tense: "past" | "present"
                - voice_type: "character_voice" | "author_voice"
                - metaphor_domains: List[str]
                - anti_patterns: List[str]
                - phase_evolution: Dict[str, str]

        Returns:
            VoiceCalibrationDocument ready for KB storage
        """
        result = self._tournaments.get(tournament_id)
        if not result:
            raise ValueError(f"Tournament {tournament_id} not found")

        if result.status != TournamentStatus.AWAITING_SELECTION:
            raise ValueError(f"Tournament not ready for selection: {result.status}")

        # Find winning variant
        agent_variants = [v for v in result.variants if v.agent_id == winner_agent_id]
        if not agent_variants or winner_variant_index >= len(agent_variants):
            raise ValueError(f"Invalid winner selection")

        winning_variant = agent_variants[winner_variant_index]

        # Create Voice Calibration Document
        voice_doc = VoiceCalibrationDocument(
            project_id=result.project_id,
            pov=voice_config.get('pov', 'third_limited'),
            tense=voice_config.get('tense', 'past'),
            voice_type=voice_config.get('voice_type', 'character_voice'),
            metaphor_domains=voice_config.get('metaphor_domains', []),
            sentence_rhythm=voice_config.get('sentence_rhythm', 'varied'),
            vocabulary_level=voice_config.get('vocabulary_level', 'literary'),
            characteristic_phrases=voice_config.get('characteristic_phrases', []),
            anti_patterns=voice_config.get('anti_patterns', []),
            phase_evolution=voice_config.get('phase_evolution', {}),
            winning_agent=winner_agent_id,
            reference_sample=winning_variant.content,
        )

        # Store in KB
        await self._store_voice_calibration(result.project_id, voice_doc)

        # Update tournament status
        result.winner_agent_id = winner_agent_id
        result.winner_variant_index = winner_variant_index
        result.status = TournamentStatus.COMPLETE
        result.completed_at = datetime.now(timezone.utc).isoformat()

        return voice_doc

    async def _store_voice_calibration(
        self,
        project_id: str,
        voice_doc: VoiceCalibrationDocument,
    ):
        """Store voice calibration in KB for promotion to Knowledge Graph."""
        kb = self.kb_service

        # Store main document
        await kb.set(
            project_id=project_id,
            key="voice_calibration",
            value=json.dumps(voice_doc.to_dict()),
            category="voice",
            source="voice_calibration_tournament",
        )

        # Store individual components for easy query
        await kb.set(
            project_id=project_id,
            key="voice_pov",
            value=voice_doc.pov,
            category="voice",
            source="voice_calibration_tournament",
        )

        await kb.set(
            project_id=project_id,
            key="voice_tense",
            value=voice_doc.tense,
            category="voice",
            source="voice_calibration_tournament",
        )

        await kb.set(
            project_id=project_id,
            key="voice_winning_agent",
            value=voice_doc.winning_agent,
            category="voice",
            source="voice_calibration_tournament",
        )

        await kb.set(
            project_id=project_id,
            key="voice_metaphor_domains",
            value=json.dumps(voice_doc.metaphor_domains),
            category="voice",
            source="voice_calibration_tournament",
        )

        await kb.set(
            project_id=project_id,
            key="voice_anti_patterns",
            value=json.dumps(voice_doc.anti_patterns),
            category="voice",
            source="voice_calibration_tournament",
        )

        await kb.set(
            project_id=project_id,
            key="voice_reference_sample",
            value=voice_doc.reference_sample,
            category="voice",
            source="voice_calibration_tournament",
        )

    # =========================================================================
    # Voice Reference Bundle Generation
    # =========================================================================

    async def generate_voice_bundle(
        self,
        project_id: str,
        output_dir: Path,
    ) -> Dict[str, Path]:
        """
        Generate Voice Reference Bundle files for Director Mode.

        These files travel with every agent call during scene writing.

        Args:
            project_id: The project
            output_dir: Directory to write files

        Returns:
            Dict mapping file type to path
        """
        # Get voice calibration from KB
        voice_json = await self.kb_service.get(project_id, "voice_calibration")
        if not voice_json:
            raise ValueError(f"No voice calibration found for project {project_id}")

        voice_doc = json.loads(voice_json)

        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        files = {}

        # 1. Voice Gold Standard
        gold_standard_path = output_dir / "Voice-Gold-Standard.md"
        gold_standard_content = self._generate_gold_standard(voice_doc)
        gold_standard_path.write_text(gold_standard_content)
        files['gold_standard'] = gold_standard_path

        # 2. Voice Anti-Pattern Sheet
        anti_pattern_path = output_dir / "Voice-Anti-Pattern-Sheet.md"
        anti_pattern_content = self._generate_anti_pattern_sheet(voice_doc)
        anti_pattern_path.write_text(anti_pattern_content)
        files['anti_patterns'] = anti_pattern_path

        # 3. Phase Evolution Guide
        if voice_doc.get('phase_evolution'):
            phase_path = output_dir / "Phase-Evolution-Guide.md"
            phase_content = self._generate_phase_guide(voice_doc)
            phase_path.write_text(phase_content)
            files['phase_evolution'] = phase_path

        return files

    def _generate_gold_standard(self, voice_doc: Dict) -> str:
        """Generate the Voice Gold Standard markdown file."""
        return f"""# Voice Gold Standard

**Project Voice Calibration Document**
Generated: {datetime.now().strftime('%Y-%m-%d')}

---

## Narrative Structure

- **POV**: {voice_doc['pov'].replace('_', ' ').title()}
- **Tense**: {voice_doc['tense'].title()}
- **Voice Type**: {voice_doc['voice_type'].replace('_', ' ').title()}

---

## Voice Characteristics

### Metaphor Domains
{chr(10).join(f'- {domain}' for domain in voice_doc.get('metaphor_domains', []))}

### Sentence Rhythm
{voice_doc.get('sentence_rhythm', 'varied')}

### Vocabulary Level
{voice_doc.get('vocabulary_level', 'literary')}

### Characteristic Phrases
{chr(10).join(f'- "{phrase}"' for phrase in voice_doc.get('characteristic_phrases', []))}

---

## Reference Sample

The following sample represents the target voice quality:

```
{voice_doc.get('reference_sample', '')}
```

---

## Voice Authentication Tests

### Test 1: Authenticity Test
**Question**: Does this sound like the narrator experiencing/observing, or AI explaining?

- 10 points: Character in moment, voice natural
- 7 points: Mostly authentic, occasional AI-explaining moments
- 4 points: Mix of authentic and academic commentary
- 0 points: Sounds like AI studying character

### Test 2: Purpose Test
**Question**: Does this scene serve its story function?

- 10 points: Every beat advances plot AND develops character AND reinforces theme
- 7 points: Serves function but sometimes tells instead of shows
- 4 points: Generic well-written prose
- 0 points: Scene doesn't serve story needs

### Test 3: Fusion Test
**Question**: Does voice integrate knowledge and personality seamlessly?

- 10 points: Character knowledge serves voice naturally
- 7 points: Mostly seamless, occasional info-dump
- 4 points: Knowledge OR personality, not fused
- 0 points: Academic exposition without character

---

## Tournament Winner

**Agent**: {voice_doc.get('winning_agent', 'Not specified')}

This agent demonstrated the best alignment with the target voice characteristics.

---

*Use this document as the primary voice reference for all scene generation.*
"""

    def _generate_anti_pattern_sheet(self, voice_doc: Dict) -> str:
        """Generate the Voice Anti-Pattern Sheet markdown file."""
        anti_patterns = voice_doc.get('anti_patterns', [])

        # Default universal AI patterns to always include
        universal_patterns = [
            ('AI Vocabulary', ['crucial', 'pivotal', 'tapestry', 'intricate', 'enduring', 'fostering', 'showcase', 'underscore']),
            ('Promotional Puffery', ['continues to captivate', 'groundbreaking', 'stunning natural beauty', 'enduring legacy', 'nestled', 'in the heart of']),
            ('Shallow Analysis', ['ensuring...', 'highlighting...', 'emphasizing...', 'reflecting...', 'underscoring...', 'showcasing...']),
            ('Formulaic Structures', ['In summary', 'In conclusion', 'Overall', 'It\'s important to note']),
        ]

        return f"""# Voice Anti-Pattern Sheet

**Patterns to Avoid**
Generated: {datetime.now().strftime('%Y-%m-%d')}

---

## Project-Specific Anti-Patterns

These patterns are specifically forbidden for this project's voice:

{chr(10).join(f'### {pattern}{chr(10)}Avoid using this pattern in any scene.' for pattern in anti_patterns) if anti_patterns else '*No project-specific anti-patterns defined.*'}

---

## Universal AI Anti-Patterns

These patterns reveal AI-generated text and should be avoided in all creative writing:

{chr(10).join(f'''### {name}
**Flag Words**: {', '.join(f'"{w}"' for w in words)}
''' for name, words in universal_patterns)}

---

## Detection Rules

### Zero-Tolerance Violations
Each instance = -2 points in scoring

- First-person italics (if using character voice): `*We realized*` → `*[Character] realized*`
- "With [adjective] precision" patterns
- Computer metaphors for psychology: "brain processed" → use metaphor domains

### Formulaic Patterns
Each instance = -1 point in scoring

- "walked [adverb]ly" → Show specific movement
- "despite/because/even though" → Cut explanatory language
- "the air seemed to" → Character-specific sensory details

---

## Quick Check Regex Patterns

```python
# Zero-tolerance
r'\\*[^*]*\\b(we|I)\\b[^*]*\\*'  # First-person italics
r'\\bwith \\w+ precision\\b'      # With X precision

# AI vocabulary
r'\\b(crucial|pivotal|tapestry|intricate|enduring|fostering)\\b'

# Promotional
r'\\b(nestled|boasts a|in the heart of)\\b'
```

---

*Reference this sheet when scoring scenes and during enhancement passes.*
"""

    def _generate_phase_guide(self, voice_doc: Dict) -> str:
        """Generate the Phase Evolution Guide markdown file."""
        phase_evolution = voice_doc.get('phase_evolution', {})

        phases_content = ""
        for phase, description in phase_evolution.items():
            phases_content += f"""### {phase}
{description}

"""

        return f"""# Phase Evolution Guide

**How Voice Changes Through the Story**
Generated: {datetime.now().strftime('%Y-%m-%d')}

---

## Overview

The narrative voice evolves as the story progresses. This guide defines how the voice
should shift through each major phase/act of the story.

---

## Phase Definitions

{phases_content if phases_content else '*No phase evolution defined.*'}

---

## Voice Calibration by Phase

When writing scenes, check which phase/act the scene belongs to and calibrate
the voice accordingly:

1. Check the current act/phase
2. Reference the phase description above
3. Adjust metaphor density, vocabulary complexity, and emotional register
4. Maintain core voice characteristics while applying phase modifications

---

*Use this guide alongside the Voice Gold Standard for phase-appropriate scene generation.*
"""


# =============================================================================
# Singleton Access
# =============================================================================

_voice_calibration_service: Optional[VoiceCalibrationService] = None


def get_voice_calibration_service() -> VoiceCalibrationService:
    """Get or create the voice calibration service singleton."""
    global _voice_calibration_service
    if _voice_calibration_service is None:
        _voice_calibration_service = VoiceCalibrationService()
    return _voice_calibration_service
